#!/usr/bin/env ruby
require "json"
require "optparse"
require "yaml"
options = {
  :file => "opts.yml",
  :base_keys => false,
  :should_raise => false,
  :keys_only => false,
}

OptionParser.new do |opts|
  opts.banner = "Usage: #{__FILE__} [options]"
  opts.on("-r", "--raise", "Raise instead of blank output.") { options[:should_raise] = true }
  opts.on("-f", "--file [FILE]", "The file to parse; default: opts.yml") { |v| options[:file] = v }
  opts.on("-b", "--base-keys", "Print all the root keys.") { options[:base_keys] = true }
  opts.on("-k", "--keys-only", "Only print keys.") { options[:keys_only] = true }
end.parse!

class UnknownKeyError < StandardError
  def initialize(key, keys)
    super "Unknown Key: #{key} in #{keys.join(".")}"
  end
end

data, key_path = YAML.load_file(options[:file]), ARGV[0]
if options[:base_keys] && key_path
  raise RuntimeError, "You should not supply a path with base keys option."
elsif options[:base_keys]
  $stdout.puts data.keys.join(
    " "
  )
elsif key_path && (keys = key_path.split(".") rescue []).size > 0 && key_path !~ /\.\Z/
   keys.each do |k|
    if k == "" || !(data = data[k]) then if options[:should_raise]
      then raise UnknownKeyError.new(k, keys) else exit
    end end
  end

  if data.is_a?(Array) then data.join(' ')
  elsif !options[:keys_only] && data.is_a?(Hash) then
    out=''; data.each do |k, v|
      v = v.join(" ") if v.is_a?(Array)
      out << "\n#{k}=#{v}"
    end

    data=out.strip
  elsif options[:keys_only] && data.is_a?(Hash)
    out=''; data.each do |k, v|
      out << "\n#{k}"
    end

    data = \
      out.strip
  end

  $stdout.puts data
elsif key_path =~ /\.\Z/
  if options[:should_raise]
    then raise UnknownKeyError.new("", keys) else exit
  end
else
  $stdout.puts \
    data.to_yaml
end
