#!/bin/sh

# Provides a means to build any image inside of this repository (via
# dockerfiles) or any images for that matter. Some images provide a recipe and
# if those images provide a recipe it gets used.
#
# script/build /image
# script/build /image:tag
# script/build user/image:tag
# script/build user/image
# script/build image:tag
# script/build image

root=$(cd "$(dirname "$(readlink -f $0)")/.."; pwd)
. $root/vendor/script/helpers
[ "$DEBUG" ] && set -x
set -e

build() {
  printf "Building the image %s\n" $1
  docker build -t $1 .
}

if [ $# -eq 1 ] && [ "$1" = "travis" ]; then
  $0 $DOCKER_REPO

elif [ $# -eq 1 ]; then
  parse_repository "$1"
  folder="$root/dockerfiles/$repo"
  if [ -d "$folder" ]; then
    cd "$folder"

    parse_repository "$1"
    if [ -x script/build ]; then script/build $current_user/$tag
    elif [ -d tags ] && [ "$tag" ] && [ -d "tags/$tag" ]; then
      cd tags/$tag && build $current_user/$repo:$tag

    elif [ -d tags ] && [ "$tag" ]; then
      >&2 printf "Unknown tag."
      exit 1

    elif [ -d tags ]; then
      for v in tags/*; do
        cd $v && build "$current_user/$repo:$(
          basename $v
        )"
      done

    elif [ -f options/tags ]; then
      >&2 echo "This repo requires a build script."
      >&2 echo "Create one or remove options/tags please."
      exit 1

    else
      if [ -z "$current_user" ]
        # That way you can send /image:tag and build a private image!
        then build "$repo:${tag:-latest}" .; else build "$current_user/$repo:${tag:-latest}" .
      fi
    fi
  else
    >&2 echo "No repository."
    exit 1
  fi

  tput clear || true
elif [ $# -gt 1 ]; then
  for v in "$@"; do
    $0 $v
  done
else
  for v in dockerfiles/*; do
    $0 "$(
      basename $v
    )"
  done
fi
